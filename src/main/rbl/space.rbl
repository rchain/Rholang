;; -*- mode: Lisp;-*- 
;; Filename:    space.rbl 
;; Authors:     luciusmeredith                                                    
;; Creation:    Thu Feb 23 18:57:26 2017 
;; Copyright:   See site license
;; Description: Basic Linda pattern
;; ------------------------------------------------------------------------

;;; TODO: Add tag for whether persistent
(add '**wildcard** #niv) ;; TODO: Add wildcard token in Rosette implementation and swap out #niv

(defOprn append)
(defPure Tuple (append item) (reverse [item & (reverse (self))]))

;;; Deletes element at position i in Tuple
(defOprn delete-i)
(defPure Tuple (delete-i p)
    (concat (prim-sub-object (self) 0 p)
        (prim-sub-object (self) (fx+ p 1)
            (fx- (prim-size (self)) (fx+ p 1)))))

(defOprn consume)
(defOprn produce)
(defOprn unify?)
(defOprn match?)
(defOprn production?)

(defActor NameSpace (slots& chart (new RblTable))
    ;;; TODO: We currently do not support prologue style unification (bidirectional) pattern matching
    ;;; Potential implementation: (if (type? ptrn candidate) (seq (update) ((proc [ptrn] ptrn) candidate)) (seq (update) #niv)) )
    (pure (unify? ptrn candidate) #t)
    (pure (match? ptrn candidate) (if (= ptrn **wildcard**) #t (type? ptrn candidate)))
    ;;; storedValue is the tuple [data continuation]
    (pure (production? storedValue) (not (null? (head storedValue))))
)

(defOprn tuplespace-tbl-get-or-create)
(defPure RblTable (tuplespace-tbl-get-or-create channel)
    (let [[subspace (tbl-get (self) channel)]]
        (if (absent? subspace)
            (seq
                (tbl-add (self) channel (new RblTable))
                (tbl-get (self) channel)
            )
            subspace
        )
    )
)

(defRMethod NameSpace (consume ctxt & location)
    ;;; by makng this a reflective method - RMethod - we gain access to the awaiting continuation
    ;;; bound to the formal parameter ctxt
    (let* [[[channel unification_ptrn product_ptrn] location]
        ;;; the channel and the pattern of incoming messages to look for are destructured and bound
            [subspace (tuplespace-tbl-get-or-create chart channel)]
                ;;; the incoming messages associated with the channel are collected in a subtable
                ;;; in this sense we can see that the semantic framework supports a compositional
                ;;; topic/subtopic/subsubtopic/â€¦ structuring technique that unifies message passing
                ;;; with content delivery primitives
                ;;; the channel name becomes the topic, and the pattern structure becomes
                ;;; the subtopic tree
                ;;; this also unifies with the URL view of resource access
            [candidates (names subspace)]
            [[extractions remainder]
            (fold candidates
                (proc [e acc k]
                    (let [[[hits misses] acc]
                        [binding (unify? NameSpace unification_ptrn e)]]
                (if (niv? binding)
                    (k [hits [e & misses]])
                    (k [[[e binding] & hits] misses])))) [[] []])]
                        ;;; note that this is generic in the unify? and miss? predicates
                        ;;; matching could be unification (as it is in SpecialK) or it could be
                        ;;; a number of other special purpose protocols
                        ;;; the price for this genericity is performance
                        ;;; there is decent research showing that there are hashing disciplines
                        ;;; that could provide a better than reasonable approximation of unification
            [[productions consummation]
            (fold extractions
                (proc [[e binding] acc k]
                    (let* [[[productions consumers] acc]
                            [storedValue (tbl-get subspace e)]
                            [[data continuation] storedValue]]
                    (if (production? NameSpace storedValue)
                        (k [[[[e binding] data] & productions] consumers])
                        (k [productions [[e continuation] & consumers]])))) [[] []])]]
                        ;;; this divides the hits into those matches that are data and
                        ;;; those matches that are continuations
                        ;;; and the rest of the code sends data to the awaiting continuation
                        ;;; and appends the continuation to those matches that are currently
                        ;;; data starved
                        ;;; this is a much more fine-grained view of excluded middle

        (seq
            ;;; Policy: Consume the first product that is matched
            (let [[result
                (map productions
                    (proc [_ [[unification_ptrn binding] product_list]]
                        (map product_list
                            (proc [i product]
                                (if (match? NameSpace product_ptrn product)
                                    (seq
                                        (let [[updated_product_list (delete-i product_list i)]]
                                            (tbl-add subspace unification_ptrn updated_product_list)
                                        )
                                        (update!)
                                        (ctxt-rtn ctxt product)
                                        #t
                                    )
                                )
                            )
                        )
                    )
                )
            ]]
                (if (null? result)
                    (seq
                        ;;; If continuation was not consumed by a matching product above, store it and suspend
                        (print "DEBUG: Waiting for data")
                        (let [[stored_value (tbl-get subspace unification_ptrn)]]
                            (if (= #absent stored_value)
                                (tbl-add subspace unification_ptrn [[] [[product_ptrn ctxt]]])
                                (let [[[products continuations] stored_value]]
                                    (tbl-add subspace unification_ptrn [products (append continuations [product_ptrn ctxt])])
                                )
                            )
                        )
                        (update!)
                    )
                )
            )
            (update!)
        )
    )
)


;;; This code is perfectly dual to the consumer code and so all the comments
;;; there apply in the corresponding code sites
(defRMethod NameSpace (produce ctxt & production)
    (let* [[[channel unification_ptrn product] production]
            [subspace (tuplespace-tbl-get-or-create chart channel)]
            [candidates (names subspace)]
            [[extractions remainder]
            (fold candidates
                (proc [e acc k]
                    (let [[[hits misses] acc]
                        [binding (unify? NameSpace unification_ptrn e)]]
                    (if (niv? binding)
                        (k [hits [e & misses]])
                        (k [[[e binding] & hits] misses])))) [[] []])]
            [[productions consummation]
            (fold extractions
                (proc [[e binding] acc k]
                    (let* [[[productions consumers] acc]
                            [storedValue (tbl-get subspace e)]
                            [[_data_list continuation_list] storedValue]]
                    (if (production? NameSpace storedValue)
                        (k [[] consumers])
                        (k [productions [[[e binding] continuation_list] & consumers]])))) [[] []])]]
        (seq
            ;;; Policy: Send the product to the first continuation that is matched
            (let [[result
            (map consummation
                (proc [_ [[unification_ptrn binding] continuation_list]]
                    (map continuation_list
                        (proc [i [product_ptrn continuation]]
                            (if (match? NameSpace product_ptrn product)
                                (seq
                                    (let [[updated_continuation_list (delete-i continuation_list i)]]
                                        (tbl-add subspace unification_ptrn updated_continuation_list)
                                    )
                                    (send ctxt-rtn continuation [[[unification_ptrn binding] product]])
                                    (update!)
                                    (ctxt-rtn ctxt product)
                                    #t
                                )
                            )
                        )
                    )
                )
            )
            ]]
            ;;; If product was not consumed by a matching continuation above, store it
            (if (null? result)
                (seq
                    (let [[stored_value (tbl-get subspace unification_ptrn)]]
                        (if (= #absent stored_value)
                            (tbl-add subspace unification_ptrn [[product] [[]]])
                            (let [[[products continuations] (tbl-get subspace unification_ptrn)]]
                                (tbl-add subspace unification_ptrn [(append products product) continuations])
                            )
                        )
                    )
                    (update!)
                    (ctxt-rtn ctxt product)
                )
            )
        )
        (update!)
        )
    )
)
